note

	description: "Produces DB/2 version 7.1 SQL output"

	comments:
	"1. User defined data types (with create distinct type) are not supported.%
	%There use is quite awkward it seems.%
	%2. Add assert support with the generated always option."

	author:     "Berend de Boer <berend@pobox.com>"
	copyright:  "Copyright (c) 2001-2002, Berend de Boer"

class

	SQL_GENERATOR_DB2_71


inherit

	SQL_GENERATOR_ADVANCED
		redefine
			CommandSeparator,
			AutoPrimaryKeySupported,
			AutoPrimaryKeyConstraint,
			TemporaryTablesSupported,
			ExistentialFromTable,
			CreateTemporaryTableStatement,
			FinishTemporaryTableStatement,
			TemporaryTablePrefix,
			CreateTemporaryValueTable,
			ExtendIndexSupported,
			DropColumnSupported,
			value_identifier,
			sql_expression_as_boolean_value,
			sql_last_auto_generated_primary_key,
			SupportsDefaultValues,
			make_valid_sp_identifier,
			StoredProcedureUserDeclarationBeforeBody,
			sp_define_in_param,
			sp_define_out_param,
			sp_get_auto_generated_primary_key,
			sp_header_end,
			sp_result_parameter,
			sp_use_param,
			sp_user_declaration,
			create_select_function,
			create_select_list,
			create_sync_auto_generated_primary_key_with_supplied_value,
			create_init,
			DomainsSupported,
			IdentifierWithSpacesSupported,
			MaxConstraintIdentifierLength,
			ColumnNullAllowed,
			ExpressionsInDefaultClauseSupported,
			SQLTrue,
			SQLFalse,
			SupportsTrueBoolean,
			sql_string_combine_separator,
			create_end,
			sqlsysfunction_current_timestamp,
			sqlsysfunction_system_user,
			datatype_int,
			quote_identifier,
			index_name
		end


create

	make


feature -- About this generator

	target_name: STRING
			-- Name and version of dialect.
		once
			Result := "DB/2 version 7.1"
		end


feature -- domain options

	DomainsSupported: BOOLEAN
		once
			Result := False
		end


feature -- Identifiers

	IdentifierWithSpacesSupported: BOOLEAN
		once
			Result := True
		end

	MaxIdentifierLength: INTEGER
			-- table names may be 128
		once
			Result := 30
		end

	MaxConstraintIdentifierLength: INTEGER
		once
			Result := 18
		end

	MaxIndexNameLength: INTEGER = 18


feature -- Table options

	AutoPrimaryKeySupported: BOOLEAN
		once Result := True end

	AutoPrimaryKeyConstraint: STRING
		once
			Result := "not null primary key generated by default as identity"
		end

	ColumnNullAllowed: BOOLEAN
		once
			Result := False
		end

	ExpressionsInDefaultClauseSupported: BOOLEAN = False
			-- Does the SQL dialect support expressions (1 + 1 for
			-- example) in the default clause?


feature --  Temporary table support

	TemporaryTablesSupported: BOOLEAN
			-- Support 'create temporary table' statement.
		once
			Result := True
		end

	CreateTemporaryTableStatement: STRING
		do
			Result := "declare global temporary table"
		end

	FinishTemporaryTableStatement: STRING
			-- String to output when temporary table definition is finished.
		once
			Result := " on commit preserve rows not logged with replace"
		end

	TemporaryTablePrefix: STRING
			-- Optional prefix for temporary tables.
		once
			Result := "session."
		end


feature -- purge options

	DropColumnSupported: BOOLEAN
			-- can columns be removed?
		once
			Result := False
		end


feature -- Booleans

	SQLTrue: STRING once Result := "1" end
	SQLFalse: STRING once Result := "0" end

	SupportsTrueBoolean: BOOLEAN
		do
			Result := False
		end


feature -- Strings

	sql_string_combine_separator: STRING = " || "


feature -- actual creation of sql statements, you may redefine these

	create_end (database: STRING)
		do
			std.output.put_string ("disconnect ")
			std.output.put_string (database)
			std.output.put_string (CommandSeparator)
			std.output.put_string ("%N")
		end

	create_primary_key_generator (type: XPLAIN_TYPE)
		do
			-- nothing
		end

	create_use_database (database: STRING)
			-- start using a certain database
		do
			std.output.put_string ("connect to ")
			std.output.put_string (database)
			std.output.put_string (CommandSeparator)
			std.output.put_string ("%N")
		end

feature -- drop statements

	drop_primary_key_generator (type: XPLAIN_TYPE)
		do
			-- nothing
		end


feature -- ansi niladic functions

	sqlsysfunction_current_timestamp: STRING
		once
			Result := "CURRENT TIMESTAMP"
		end

	sqlsysfunction_system_user: STRING
		once
			Result := "USER"
		end


feature -- Identifiers

	quote_identifier (identifier: STRING): STRING
			-- Return identifier, surrounded by quotes.
		local
			s: STRING
		do
			s := "%"" + identifier + "%""
			Result := s
		end

feature -- Index name

	index_name (index: XPLAIN_INDEX): STRING
		do
			Result := "idx_" + index.type.sqlname (Current) + "_" + index.name
			Result.keep_head (MaxIndexNameLength)
			Result := make_valid_identifier (Result)
		end

feature -- Command separation

	default_command_seperator: STRING = "@"
	stored_procedure_command_seperator: STRING = ";"

	CommandSeparator: STRING
		do
			if is_stored_procedure then
				Result := stored_procedure_command_seperator
			else
				Result := default_command_seperator
			end
		end


feature -- extend options

	ExtendIndexSupported: BOOLEAN
		do
			Result := False
		end


feature -- select options

	ExistentialFromTable: STRING = "sysibm.sysdummy1"
			-- In case an extistential from is needed, the name of the
			-- get table is used when this routine returns Void.


feature -- Values

	CreateTemporaryValueTable: BOOLEAN
			-- DB/2 cannot alter a temporary table.
		do
			Result := False
		end

	value_identifier (value: XPLAIN_VALUE): STRING
			-- Return identifier, not quoted.
		do
			Result := precursor (value)
			if is_stored_procedure then
				Result := no_space_identifier (Result)
			end
		end


feature -- Auto primary key

	sql_last_auto_generated_primary_key	(type: XPLAIN_TYPE): STRING
			-- Return code to get the last auto-generated primary
			-- key. It's not type specific.
		once
			Result := "IDENTITY_VAL_LOCAL()"
		end


feature -- insert options

	SupportsDefaultValues: BOOLEAN
			-- Does the dialect supports the default values clause in an
			-- insert statement?
		once
			Result := False
		end


feature -- create SQL

	create_init (type: XPLAIN_TYPE)
		local
			cursor: DS_LINEAR_CURSOR [XPLAIN_ATTRIBUTE]
			comma: STRING
		do
			std.output.put_string (format ("%Ncreate trigger $s no cascade before insert on $s%Nreferencing new as new%Nfor each row mode db2sql%Nbegin atomic%N", <<quote_valid_identifier("tr_" + type.sqlname (Current) + "Init"), type.quoted_name (Current)>>))
			-- Enable sp to change CommandSeparator
			is_stored_procedure := True
			from
				cursor := type.new_init_attributes_cursor (Current)
				cursor.start
				comma := ""
			until
				cursor.after
			loop
				if
					not cursor.item.is_init_default or else
					(attached cursor.item.init as init and then
					 not init.is_constant)
				then
					std.output.put_string (Tab)
					Tab.append_string ("  ")
					std.output.put_string (format ("set new.$s = $s", <<cursor.item.q_sql_select_name (Current), sql_init_expression (cursor.item)>>))
					Tab.remove_tail (2)
					std.output.put_string (CommandSeparator)
					std.output.put_character ('%N')
				end
				cursor.forth
			end
			is_stored_procedure := False
			std.output.put_string ("end")
			std.output.put_string (CommandSeparator)
			std.output.put_string ("%N%N")
		end


feature -- Return sql code

	sql_expression_as_boolean_value (expression: XPLAIN_EXPRESSION): STRING
			-- Return SQL code for extension that is a logical
			-- expression. For SQL dialects that don't support Booleans,
			-- it might need to map the Boolean result to a 'T' or 'F'
			-- value.
		do
			Result := format (once "case when $s then 1 else 0 end", <<expression.sqlvalue (Current)>>)
		end


feature -- Stored procedure options

	StoredProcedureUserDeclarationBeforeBody: BOOLEAN = False
			-- Must any value and other declarations be put before the
			-- procedure body begins?


feature -- Stored procedure support

	make_valid_sp_identifier (name: STRING): STRING
			-- Return a name without spaces.
		do
			Result := no_space_identifier (name)
		end

	sp_define_in_param (name: STRING): STRING
			-- Return `name' formatted as an sp input parameter, as it
			-- should appear in the header/definition of a stored
			-- procedure.
			-- Certain dialects have conventions for this like using a
			-- '@' in front of every identifier.  Spaces and such should
			-- be removed if necessary, or the entry should be quoted if
			-- that is supported for sp's.
		local
			s: STRING
		do
			s := sp_define_param_name (name)
			create Result.make (3 + s.count)
			Result.wipe_out
			Result.append_string ("in ")
			Result.append_string (s)
		end

	sp_define_out_param (name: STRING): STRING
			-- Return `name' formatted as an output input parameter, as it
			-- should appear in the header/definition of a stored
			-- procedure. See also `sp_define_in_param'.
		local
			s: STRING
		do
			s := sp_define_param_name (name)
			create Result.make (4 + s.count)
			Result.wipe_out
			Result.append_string ("out ")
			Result.append_string (s)
		end

	sp_get_auto_generated_primary_key (type: XPLAIN_TYPE): STRING
		do
			create Result.make (64)
			Result.wipe_out
			Result.append_string ("set ")
			Result.append_string (sp_define_param_name (type.sqlpkname (Current)))
			Result.append_string (" = ")
			Result.append_string (sql_last_auto_generated_primary_key (type))
			Result.append_string (CommandSeparator)
			Result.append_string ("%N")
		end

	sp_header_end
			-- Emit code to end stored procedure declaration.
		do
			std.output.put_string ("language sql%N")
		end

	sp_result_parameter (a_procedure: detachable XPLAIN_PROCEDURE)
			-- Output the proper clause when rows are returned or not.
		do
			std.output.put_character ('%N')
			std.output.put_string (Tab)
			if a_procedure /= Void and then a_procedure.returns_rows (Current) then
				std.output.put_string ("dynamic result sets 1%N")
				std.output.put_string (Tab)
			end
		end

	sp_use_param (name: STRING): STRING
			-- Return stored procedure parameter `name' formatted
			-- according to the dialects convention when using
			-- parameters in sql code. It is usually prefixed by '@' or
			-- ':'.
			-- Spaces and such should be removed if necessary, or the
			-- entry should be quoted if that is supported for sp's.
		do
			Result := no_space_identifier (name)
		end

	sp_user_declaration (procedure: XPLAIN_PROCEDURE)
			-- Any declarations needed in a user procedure like
			-- declarations for the value statement or cursors.
			-- Exact location depends on
			-- `StoredProcedureUserDeclarationBeforeBody'.
		do
			-- For DB2 I perhaps want to put the cursor declarations here
			-- as well. In that case I don't need to have additional
			-- begin..end statements.
			from
				procedure.statements.start
			until
				procedure.statements.after
			loop
				if attached {XPLAIN_VALUE_STATEMENT} procedure.statements.item_for_iteration as value_statement then
					optional_create_value_declare (value_statement.value)
				end
				procedure.statements.forth
			end
		end


feature -- SQL creation statements

	create_select_function (selection_list: XPLAIN_SELECTION_FUNCTION)
			-- Output a select function that returns a scalar value.
		do
			if is_stored_procedure then
				std.output.put_character ('%N')
				std.output.put_string ("begin%N")
				std.output.put_string (Tab)
				std.output.put_string ("declare callercur cursor with return to caller for")
			end
			precursor (selection_list)
			if is_stored_procedure then
				std.output.put_string (Tab)
				std.output.put_string ("open callercur")
				std.output.put_string (CommandSeparator)
				std.output.put_character ('%N')
				std.output.put_string ("end")
				std.output.put_string (CommandSeparator)
				std.output.put_character ('%N')
			end
		end

	create_select_list (selection_list: XPLAIN_SELECTION_LIST)
			-- For DB/2 selects in a stored procedure have to be treated
			-- differently.
		do
			if is_stored_procedure then
				std.output.put_character ('%N')
				std.output.put_string ("begin%N")
				std.output.put_string (Tab)
				std.output.put_string ("declare callercur cursor with return to caller for")
			end
			precursor (selection_list)
			if is_stored_procedure then
				std.output.put_string (Tab)
				std.output.put_string ("open callercur")
				std.output.put_string (CommandSeparator)
				std.output.put_character ('%N')
				std.output.put_string ("end")
				std.output.put_string (CommandSeparator)
				std.output.put_character ('%N')
			end
		end

	create_select_value_inside_sp (a_value: XPLAIN_VALUE)
			-- Inside a stored procedure, attempt to fool DB/2 into
			-- returning a value. Have they ever thought about making
			-- things transparent or ready for users, and somewhat more
			-- difficult for themselves perhas? DB/2 is typically a
			-- program where all the hard decisions and implementations
			-- are left to the user.
		do
			std.output.put_string ("begin%N")
			std.output.put_string (Tab)
			std.output.put_string ("declare callercur cursor with return to caller for%N")
			std.output.put_string (Tab)
			std.output.put_string (Tab)
			std.output.put_string ("values (")
			std.output.put_string (a_value.quoted_name (Current))
			std.output.put_character (')')
			std.output.put_string (CommandSeparator)
			std.output.put_character ('%N')
			std.output.put_string (Tab)
			std.output.put_string ("open callercur")
			std.output.put_string (CommandSeparator)
			std.output.put_character ('%N')
			std.output.put_string ("end")
		end

	create_sync_auto_generated_primary_key_with_supplied_value (type: XPLAIN_TYPE; user_identification: INTEGER)
			-- Restart identity column.
		do
			std.output.put_string ("alter table ")
			std.output.put_string (type.quoted_name (Current))
			std.output.put_string (" alter column ")
			std.output.put_string (type.q_sqlpkname (Current))
			std.output.put_string (" restart with ")
			std.output.put_string ((user_identification +1 ).out)
			std.output.put_string (CommandSeparator)
			std.output.put_string ("%N")
		end

	create_value_declare_inside_sp (a_value: XPLAIN_VALUE)
			-- Emit SQL code to declare `a_value' inside a stored procedure.
		do
			std.output.put_string (Tab)
			std.output.put_string ("declare ")
			std.output.put_string (a_value.quoted_name (Current))
			std.output.put_string (" ")
			std.output.put_string (a_value.representation.datatype (Current))
			std.output.put_string (CommandSeparator)
			std.output.put_character ('%N')
		end

	create_value_assign_inside_sp (a_value: XPLAIN_VALUE)
			-- Emit code to assign `a_value'.`expression' to `a_value'
			-- inside a stored procedure.
		do
			std.output.put_string ("set ")
			std.output.put_string (a_value.quoted_name (Current))
			std.output.put_string (" = (")
			std.output.put_string (a_value.expression.outer_sqlvalue (Current))
			std.output.put_character (')')
			std.output.put_string (CommandSeparator)
			std.output.put_character ('%N')
		end


feature -- Get a variable/value

	sqlgetvalue_inside_sp (a_value: XPLAIN_VALUE): STRING
			-- SQL expression that returns the value of a value inside a
			-- stored procedure
		do
			Result := format ("($s)", <<a_value.expression.outer_sqlvalue (Current)>>)
		end


feature -- Type specification for Xplain types

	datatype_boolean (representation: XPLAIN_B_REPRESENTATION): STRING
		do
			Result := "smallint"
		end

	datatype_datetime (representation: XPLAIN_D_REPRESENTATION): STRING
		do
			Result := "timestamp"
		end

	datatype_float (representation: XPLAIN_F_REPRESENTATION): STRING
			-- platform dependent approximate numeric data type
		do
			Result := "double precision"
		end

	datatype_int (representation: XPLAIN_I_REPRESENTATION): STRING
		do
			inspect representation.length
			when 1 .. 4 then
				Result := "smallint"
			when 5 .. 9 then
				Result := "integer"
			when 10 .. 18 then
				Result := "bigint"
			else
				Result := "numeric(" + representation.length.out + ", 0)"
			end
		end

	datatype_money (representation: XPLAIN_M_REPRESENTATION): STRING
		do
			Result := "numeric(12,4)"
		end

	datatype_picture (representation: XPLAIN_P_REPRESENTATION): STRING
			-- Store pictures of up to 1MB.
		do
			Result := "blob(1M)"
		end

	datatype_text (representation: XPLAIN_T_REPRESENTATION): STRING
			-- Maximum length is 1M characters.
		do
			-- Ugly trick to return a supported data type inside stored
			-- procedures.
			if is_stored_procedure then
				Result := "varchar(32672)"
			else
				Result := "clob(1M)"
			end
		end

end
